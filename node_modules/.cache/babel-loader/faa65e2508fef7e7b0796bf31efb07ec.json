{"ast":null,"code":"/**\r\n * Records durations of time, with some design inspiration from a physical stopwatch.\r\n *\r\n * To begin recording time, create a new instance of Stopwatch and call its\r\n * {@link Stopwatch#start} method.\r\n *\r\n * Pause the stopwatch via {@link Stopwatch#stop}, then resume by calling\r\n * {@link Stopwatch#start} again.\r\n *\r\n * Use {@link Stopwatch#getTime} to get the amount of time that the stopwatch has\r\n * recorded so far (ignoring durations of time that the Stopwatch was stopped).\r\n * There's no need to stop the stopwatch before doing this.\r\n *\r\n * Similar to advanced physical stopwatches' abilities to record multiple lap times\r\n * Stopwatch supports recording multiple \"slices\" of time. See {@link Stopwatch.Slice},\r\n * {@link Stopwatch#slice}, {@link Stopwatch#getPendingSlice},\r\n * {@link Stopwatch#getCompletedSlices}, and {@link Stopwatch#getCompletedAndPendingSlices}.\r\n * NOTE: {@link Stopwatch#stop} supports an optional parameter to simultaneously\r\n *       record the current pending \"slice\".\r\n *\r\n * Use {@link Stopwatch#reset} to reset the stopwatch to its initial state.\r\n * NOTE: {@link Stopwatch#start} also supports an optional parameter to force\r\n *       a reset before (re)starting.\r\n *\r\n * See {@link Stopwatch#getState}, {@link Stopwatch#isIdle}, {@link Stopwatch#isRunning},\r\n * and {@link Stopwatch#isStopped} for testing the current state of the Stopwatch.\r\n *\r\n * By default, Stopwatch internally uses {@link Date.now} for tracking the amount of\r\n * time that has passed. This is the most compatible implementation, but has some limitations:\r\n * - Maximum precision of 1ms.\r\n * - Results can be thrown off if the computer's time is adjusted (manually or automatically)\r\n *   during execution of the code.\r\n *\r\n * If your runtime environment supports a more reliable or higher precision method for\r\n * obtaining system time or program execution time, then you can override this default\r\n * implementation by either:\r\n * - Providing a custom \"system time getter\" function to the Stopwatch constructor.\r\n * - Or using {@link Stopwatch.setDefaultSystemTimeGetter} to ensure that ALL future instances\r\n *   of Stopwatch use your custom \"system time getter\" by default.\r\n * NOTE: The unit of time/duration reported by Stopwatch is determined by the unit time\r\n *       returned by the \"system time getter\" function.\r\n *\r\n * Stopwatch is not limited to recording durations of system time. It can record the \"duration\"\r\n * (change) of any numeric value that may change over time, but is guaranteed to never decrease\r\n * over time.\r\n */\nvar Stopwatch =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Stopwatch instance.\r\n   * The unit of all durations reported by this instance will match the\r\n   * unit of time returned by the provided `getSystemTime` param.\r\n   *\r\n   * @param getSystemTime - A callback that returns the current system time.\r\n   *        Defaults to the current default system time getter as specified by the most\r\n   *        recent call to {@link Stopwatch.setDefaultSystemTimeGetter}, which in turn\r\n   *        defaults to {@link Date.now}.\r\n   */\n  function Stopwatch(getSystemTime) {\n    if (getSystemTime === void 0) {\n      getSystemTime = defaultSystemTimeGetter;\n    }\n\n    this.getSystemTime = getSystemTime;\n    /**\r\n     * The total amount of system time the stopwatch has been stopped since\r\n     * the last reset.\r\n     */\n\n    this.stopDuration = 0;\n    /**\r\n     * Recorded results of all completed slices since the the last reset.\r\n     */\n\n    this.completedSlices = [];\n  }\n  /**\r\n   * Get the current state of this stopwatch.\r\n   *\r\n   * @return the current state of this stopwatch.\r\n   */\n\n\n  Stopwatch.prototype.getState = function () {\n    if (this.startSystemTime === undefined) {\n      return Stopwatch.State.IDLE;\n    } else if (this.stopSystemTime === undefined) {\n      return Stopwatch.State.RUNNING;\n    } else {\n      return Stopwatch.State.STOPPED;\n    }\n  };\n  /**\r\n   * Test if this stopwatch is currently {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * @return true if this stopwatch is currently {@link Stopwatch.State#IDLE}.\r\n   */\n\n\n  Stopwatch.prototype.isIdle = function () {\n    return this.getState() === Stopwatch.State.IDLE;\n  };\n  /**\r\n   * Test if this stopwatch is currently {@link Stopwatch.State#RUNNING}.\r\n   *\r\n   * @return true if this stopwatch is currently {@link Stopwatch.State#RUNNING}.\r\n   */\n\n\n  Stopwatch.prototype.isRunning = function () {\n    return this.getState() === Stopwatch.State.RUNNING;\n  };\n  /**\r\n   * Test if this stopwatch is currently {@link Stopwatch.State#STOPPED}.\r\n   *\r\n   * @return true if this stopwatch is currently {@link Stopwatch.State#STOPPED}.\r\n   */\n\n\n  Stopwatch.prototype.isStopped = function () {\n    return this.getState() === Stopwatch.State.STOPPED;\n  };\n  /**\r\n   * Get the current stopwatch time.\r\n   * This is the total amount of system time that this stopwatch has been running since\r\n   * the last reset.\r\n   *\r\n   * Returns zero if the state is currently {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * @return the current stopwatch time.\r\n   */\n\n\n  Stopwatch.prototype.getTime = function () {\n    return this.calculateStopwatchTime();\n  };\n  /**\r\n   * Get details about the current pending slice for this stopwatch, as of now.\r\n   *\r\n   * Returns a zero-length slice if the state is currently {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * @return details about the current pending slice for this stopwatch, as of now.\r\n   */\n\n\n  Stopwatch.prototype.getPendingSlice = function () {\n    return this.calculatePendingSlice();\n  };\n  /**\r\n   * Get a list of all completed/recorded slices for this stopwatch since the last reset.\r\n   * @return a list of all completed/recorded slices for this stopwatch since the last reset.\r\n   */\n\n\n  Stopwatch.prototype.getCompletedSlices = function () {\n    return Array.from(this.completedSlices);\n  };\n  /**\r\n   * Get a list of all completed/recorded slices for this stopwatch since the last reset,\r\n   * plus the current pending slice.\r\n   * @return a list of all completed/recorded slices for this stopwatch since the last reset,\r\n   * plus the current pending slice.\r\n   */\n\n\n  Stopwatch.prototype.getCompletedAndPendingSlices = function () {\n    return this.completedSlices.concat([this.getPendingSlice()]);\n  };\n  /**\r\n   * Starts (or resumes) running this stopwatch.\r\n   *\r\n   * Does nothing if the state is already {@link Stopwatch.State#RUNNING} and `forceReset`\r\n   * is false.\r\n   *\r\n   * The state is guaranteed to be {@link Stopwatch.State#RUNNING} after\r\n   * calling this method.\r\n   *\r\n   * @param forceReset - If true, then the stopwatch is {@link #reset} before starting.\r\n   */\n\n\n  Stopwatch.prototype.start = function (forceReset) {\n    if (forceReset === void 0) {\n      forceReset = false;\n    }\n\n    if (forceReset) {\n      this.reset();\n    }\n\n    if (this.stopSystemTime !== undefined) {\n      var systemNow = this.getSystemTime();\n      var stopDuration = systemNow - this.stopSystemTime; // Accumulate duration ot stop\n\n      this.stopDuration += stopDuration; // Resume running\n\n      this.stopSystemTime = undefined;\n    } else if (this.startSystemTime === undefined) {\n      var systemNow = this.getSystemTime(); // Record initial start time\n\n      this.startSystemTime = systemNow;\n      this.pendingSliceStartStopwatchTime = 0;\n    }\n  };\n  /**\r\n   * Ends the currently pending slice {@link Stopwatch.Slice}, records it, and\r\n   * starts the next pending slice.\r\n   *\r\n   * Does nothing and returns a zero-length slice if the state is\r\n   * currently {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * If the state is currently {@link Stopwatch.State#STOPPED}, then the slice\r\n   * technically ends (and the next pending slice starts) at the same time\r\n   * the stopwatch was stopped.\r\n   *\r\n   * This method does not change the state of the stopwatch.\r\n   *\r\n   * @returns the recorded slice.\r\n   */\n\n\n  Stopwatch.prototype.slice = function () {\n    return this.recordPendingSlice();\n  };\n  /**\r\n   * Stops (pauses) this stopwatch and returns the current {@link #getTime}\r\n   * result. Time will not be accumulated to this stopwatch's total running duration\r\n   * or the current pending slice while it is stopped. Call {@link #start} to resume\r\n   * accumulating time.\r\n   *\r\n   * Does nothing and returns zero if the state is currently {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * Stopping a stopwatch that is already {@link Stopwatch.State#STOPPED} will still\r\n   * record another slice if `recordPendingSlice` is true.\r\n   *\r\n   * The state will be {@link Stopwatch.State#STOPPED} after calling this method if\r\n   * the state is not currently {@link Stopwatch.State#IDLE}. otherwise, it will remain\r\n   * {@link Stopwatch.State#IDLE}.\r\n   *\r\n   * @param recordPendingSlice - If true, then also end/record the current pending slice.\r\n   *        This ensures that slice is ended exactly at the same time that the stopwatch\r\n   *        is stopped.\r\n   * @return the current {@link #getTime} result.\r\n   */\n\n\n  Stopwatch.prototype.stop = function (recordPendingSlice) {\n    if (recordPendingSlice === void 0) {\n      recordPendingSlice = false;\n    }\n\n    if (this.startSystemTime === undefined) {\n      return 0;\n    }\n\n    var systemTimeOfStopwatchTime = this.getSystemTimeOfCurrentStopwatchTime();\n\n    if (recordPendingSlice) {\n      this.recordPendingSlice(this.calculateStopwatchTime(systemTimeOfStopwatchTime));\n    }\n\n    this.stopSystemTime = systemTimeOfStopwatchTime;\n    return this.getTime();\n  };\n  /**\r\n   * Completely resets this stopwatch to its initial state.\r\n   * Clears out all recorded running duration, slices, etc.\r\n   * The state is guaranteed to be {@link Stopwatch.State#IDLE} after\r\n   * calling this method.\r\n   */\n\n\n  Stopwatch.prototype.reset = function () {\n    this.startSystemTime = this.pendingSliceStartStopwatchTime = this.stopSystemTime = undefined;\n    this.stopDuration = 0;\n    this.completedSlices = [];\n  };\n  /**\r\n   * Gets the system time equivalent of the current stopwatch time.\r\n   * If this stopwatch is currently stopped, then the system time at which it was\r\n   * stopped is returned.\r\n   * Otherwise, the current system time according to {@link Stopwatch#getSystemTime} is\r\n   * returned.\r\n   * @return the system time equivalent of the current stopwatch time.\r\n   */\n\n\n  Stopwatch.prototype.getSystemTimeOfCurrentStopwatchTime = function () {\n    return this.stopSystemTime === undefined ? this.getSystemTime() : this.stopSystemTime;\n  };\n  /**\r\n   * Calculates the current stopwatch time as of a specified system time.\r\n   * @param endSystemTime - The end system time for the calculation.\r\n   * @return the current stopwatch time as of the specified system time.\r\n   */\n\n\n  Stopwatch.prototype.calculateStopwatchTime = function (endSystemTime) {\n    if (this.startSystemTime === undefined) {\n      return 0;\n    }\n\n    if (endSystemTime === undefined) {\n      endSystemTime = this.getSystemTimeOfCurrentStopwatchTime();\n    }\n\n    return endSystemTime - this.startSystemTime - this.stopDuration;\n  };\n  /**\r\n   * Calculates the current pending slice as of a specified stopwatch time.\r\n   * @param endStopwatchTime - The end stopwatch time for the calculation.\r\n   * @return the current pending slice as of the specified stopwatch time.\r\n   */\n\n\n  Stopwatch.prototype.calculatePendingSlice = function (endStopwatchTime) {\n    if (this.pendingSliceStartStopwatchTime === undefined) {\n      return Object.freeze({\n        startTime: 0,\n        endTime: 0,\n        duration: 0\n      });\n    }\n\n    if (endStopwatchTime === undefined) {\n      endStopwatchTime = this.getTime();\n    }\n\n    return Object.freeze({\n      startTime: this.pendingSliceStartStopwatchTime,\n      endTime: endStopwatchTime,\n      duration: endStopwatchTime - this.pendingSliceStartStopwatchTime\n    });\n  };\n  /**\r\n   * Private implementation of ending/recording the currently pending slice.\r\n   * See {@link #slice} for more explanation.\r\n   * @param endStopwatchTime - The end stopwatch time of the slice.\r\n   * @return the recorded slice.\r\n   */\n\n\n  Stopwatch.prototype.recordPendingSlice = function (endStopwatchTime) {\n    if (this.pendingSliceStartStopwatchTime !== undefined) {\n      if (endStopwatchTime === undefined) {\n        endStopwatchTime = this.getTime();\n      }\n\n      var slice = this.calculatePendingSlice(endStopwatchTime); // Start the next pending slice\n\n      this.pendingSliceStartStopwatchTime = slice.endTime; // Record the slice\n\n      this.completedSlices.push(slice);\n      return slice;\n    } else {\n      return this.calculatePendingSlice();\n    }\n  };\n\n  return Stopwatch;\n}();\n\nexport { Stopwatch };\n\n(function (Stopwatch) {\n  /**\r\n   * Possible states of a {@link Stopwatch}.\r\n   */\n  var State;\n\n  (function (State) {\n    /**\r\n     * The stopwatch has not yet been started, or has been reset.\r\n     */\n    State[\"IDLE\"] = \"IDLE\";\n    /**\r\n     * The stopwatch is currently running.\r\n     */\n\n    State[\"RUNNING\"] = \"RUNNING\";\n    /**\r\n     * The stopwatch was previously running, but has been stopped.\r\n     */\n\n    State[\"STOPPED\"] = \"STOPPED\";\n  })(State = Stopwatch.State || (Stopwatch.State = {}));\n  /**\r\n   * Sets the default implementation of \"getSystemTime\" to be used by all future\r\n   * instances of {@link Stopwatch}.\r\n   * @param systemTimeGetter - A default \"getSystemTime\" implementation for\r\n   *        all future instances of {@link Stopwatch}.\r\n   *        Defaults to {@link Date.now}.\r\n   */\n\n\n  function setDefaultSystemTimeGetter(systemTimeGetter) {\n    if (systemTimeGetter === void 0) {\n      systemTimeGetter = Date.now;\n    }\n\n    defaultSystemTimeGetter = systemTimeGetter;\n  }\n\n  Stopwatch.setDefaultSystemTimeGetter = setDefaultSystemTimeGetter;\n})(Stopwatch || (Stopwatch = {}));\n/**\r\n * The default \"getSystemTime\" implementation for all new instances of\r\n * {@link Stopwatch}.\r\n * Defaults to {@link Date.now}.\r\n * Updated via {@link Stopwatch.setDefaultSystemTimeGetter}.\r\n */\n\n\nvar defaultSystemTimeGetter = Date.now;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Records durations of time, with some design inspiration from a physical stopwatch.\r\n *\r\n * To begin recording time, create a new instance of Stopwatch and call its\r\n * {@link Stopwatch#start} method.\r\n *\r\n * Pause the stopwatch via {@link Stopwatch#stop}, then resume by calling\r\n * {@link Stopwatch#start} again.\r\n *\r\n * Use {@link Stopwatch#getTime} to get the amount of time that the stopwatch has\r\n * recorded so far (ignoring durations of time that the Stopwatch was stopped).\r\n * There's no need to stop the stopwatch before doing this.\r\n *\r\n * Similar to advanced physical stopwatches' abilities to record multiple lap times\r\n * Stopwatch supports recording multiple \"slices\" of time. See {@link Stopwatch.Slice},\r\n * {@link Stopwatch#slice}, {@link Stopwatch#getPendingSlice},\r\n * {@link Stopwatch#getCompletedSlices}, and {@link Stopwatch#getCompletedAndPendingSlices}.\r\n * NOTE: {@link Stopwatch#stop} supports an optional parameter to simultaneously\r\n *       record the current pending \"slice\".\r\n *\r\n * Use {@link Stopwatch#reset} to reset the stopwatch to its initial state.\r\n * NOTE: {@link Stopwatch#start} also supports an optional parameter to force\r\n *       a reset before (re)starting.\r\n *\r\n * See {@link Stopwatch#getState}, {@link Stopwatch#isIdle}, {@link Stopwatch#isRunning},\r\n * and {@link Stopwatch#isStopped} for testing the current state of the Stopwatch.\r\n *\r\n * By default, Stopwatch internally uses {@link Date.now} for tracking the amount of\r\n * time that has passed. This is the most compatible implementation, but has some limitations:\r\n * - Maximum precision of 1ms.\r\n * - Results can be thrown off if the computer's time is adjusted (manually or automatically)\r\n *   during execution of the code.\r\n *\r\n * If your runtime environment supports a more reliable or higher precision method for\r\n * obtaining system time or program execution time, then you can override this default\r\n * implementation by either:\r\n * - Providing a custom \"system time getter\" function to the Stopwatch constructor.\r\n * - Or using {@link Stopwatch.setDefaultSystemTimeGetter} to ensure that ALL future instances\r\n *   of Stopwatch use your custom \"system time getter\" by default.\r\n * NOTE: The unit of time/duration reported by Stopwatch is determined by the unit time\r\n *       returned by the \"system time getter\" function.\r\n *\r\n * Stopwatch is not limited to recording durations of system time. It can record the \"duration\"\r\n * (change) of any numeric value that may change over time, but is guaranteed to never decrease\r\n * over time.\r\n */\r\nvar Stopwatch = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Stopwatch instance.\r\n     * The unit of all durations reported by this instance will match the\r\n     * unit of time returned by the provided `getSystemTime` param.\r\n     *\r\n     * @param getSystemTime - A callback that returns the current system time.\r\n     *        Defaults to the current default system time getter as specified by the most\r\n     *        recent call to {@link Stopwatch.setDefaultSystemTimeGetter}, which in turn\r\n     *        defaults to {@link Date.now}.\r\n     */\r\n    function Stopwatch(getSystemTime) {\r\n        if (getSystemTime === void 0) { getSystemTime = defaultSystemTimeGetter; }\r\n        this.getSystemTime = getSystemTime;\r\n        /**\r\n         * The total amount of system time the stopwatch has been stopped since\r\n         * the last reset.\r\n         */\r\n        this.stopDuration = 0;\r\n        /**\r\n         * Recorded results of all completed slices since the the last reset.\r\n         */\r\n        this.completedSlices = [];\r\n    }\r\n    /**\r\n     * Get the current state of this stopwatch.\r\n     *\r\n     * @return the current state of this stopwatch.\r\n     */\r\n    Stopwatch.prototype.getState = function () {\r\n        if (this.startSystemTime === undefined) {\r\n            return Stopwatch.State.IDLE;\r\n        }\r\n        else if (this.stopSystemTime === undefined) {\r\n            return Stopwatch.State.RUNNING;\r\n        }\r\n        else {\r\n            return Stopwatch.State.STOPPED;\r\n        }\r\n    };\r\n    /**\r\n     * Test if this stopwatch is currently {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * @return true if this stopwatch is currently {@link Stopwatch.State#IDLE}.\r\n     */\r\n    Stopwatch.prototype.isIdle = function () {\r\n        return this.getState() === Stopwatch.State.IDLE;\r\n    };\r\n    /**\r\n     * Test if this stopwatch is currently {@link Stopwatch.State#RUNNING}.\r\n     *\r\n     * @return true if this stopwatch is currently {@link Stopwatch.State#RUNNING}.\r\n     */\r\n    Stopwatch.prototype.isRunning = function () {\r\n        return this.getState() === Stopwatch.State.RUNNING;\r\n    };\r\n    /**\r\n     * Test if this stopwatch is currently {@link Stopwatch.State#STOPPED}.\r\n     *\r\n     * @return true if this stopwatch is currently {@link Stopwatch.State#STOPPED}.\r\n     */\r\n    Stopwatch.prototype.isStopped = function () {\r\n        return this.getState() === Stopwatch.State.STOPPED;\r\n    };\r\n    /**\r\n     * Get the current stopwatch time.\r\n     * This is the total amount of system time that this stopwatch has been running since\r\n     * the last reset.\r\n     *\r\n     * Returns zero if the state is currently {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * @return the current stopwatch time.\r\n     */\r\n    Stopwatch.prototype.getTime = function () {\r\n        return this.calculateStopwatchTime();\r\n    };\r\n    /**\r\n     * Get details about the current pending slice for this stopwatch, as of now.\r\n     *\r\n     * Returns a zero-length slice if the state is currently {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * @return details about the current pending slice for this stopwatch, as of now.\r\n     */\r\n    Stopwatch.prototype.getPendingSlice = function () {\r\n        return this.calculatePendingSlice();\r\n    };\r\n    /**\r\n     * Get a list of all completed/recorded slices for this stopwatch since the last reset.\r\n     * @return a list of all completed/recorded slices for this stopwatch since the last reset.\r\n     */\r\n    Stopwatch.prototype.getCompletedSlices = function () {\r\n        return Array.from(this.completedSlices);\r\n    };\r\n    /**\r\n     * Get a list of all completed/recorded slices for this stopwatch since the last reset,\r\n     * plus the current pending slice.\r\n     * @return a list of all completed/recorded slices for this stopwatch since the last reset,\r\n     * plus the current pending slice.\r\n     */\r\n    Stopwatch.prototype.getCompletedAndPendingSlices = function () {\r\n        return this.completedSlices.concat([this.getPendingSlice()]);\r\n    };\r\n    /**\r\n     * Starts (or resumes) running this stopwatch.\r\n     *\r\n     * Does nothing if the state is already {@link Stopwatch.State#RUNNING} and `forceReset`\r\n     * is false.\r\n     *\r\n     * The state is guaranteed to be {@link Stopwatch.State#RUNNING} after\r\n     * calling this method.\r\n     *\r\n     * @param forceReset - If true, then the stopwatch is {@link #reset} before starting.\r\n     */\r\n    Stopwatch.prototype.start = function (forceReset) {\r\n        if (forceReset === void 0) { forceReset = false; }\r\n        if (forceReset) {\r\n            this.reset();\r\n        }\r\n        if (this.stopSystemTime !== undefined) {\r\n            var systemNow = this.getSystemTime();\r\n            var stopDuration = systemNow - this.stopSystemTime;\r\n            // Accumulate duration ot stop\r\n            this.stopDuration += stopDuration;\r\n            // Resume running\r\n            this.stopSystemTime = undefined;\r\n        }\r\n        else if (this.startSystemTime === undefined) {\r\n            var systemNow = this.getSystemTime();\r\n            // Record initial start time\r\n            this.startSystemTime = systemNow;\r\n            this.pendingSliceStartStopwatchTime = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Ends the currently pending slice {@link Stopwatch.Slice}, records it, and\r\n     * starts the next pending slice.\r\n     *\r\n     * Does nothing and returns a zero-length slice if the state is\r\n     * currently {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * If the state is currently {@link Stopwatch.State#STOPPED}, then the slice\r\n     * technically ends (and the next pending slice starts) at the same time\r\n     * the stopwatch was stopped.\r\n     *\r\n     * This method does not change the state of the stopwatch.\r\n     *\r\n     * @returns the recorded slice.\r\n     */\r\n    Stopwatch.prototype.slice = function () {\r\n        return this.recordPendingSlice();\r\n    };\r\n    /**\r\n     * Stops (pauses) this stopwatch and returns the current {@link #getTime}\r\n     * result. Time will not be accumulated to this stopwatch's total running duration\r\n     * or the current pending slice while it is stopped. Call {@link #start} to resume\r\n     * accumulating time.\r\n     *\r\n     * Does nothing and returns zero if the state is currently {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * Stopping a stopwatch that is already {@link Stopwatch.State#STOPPED} will still\r\n     * record another slice if `recordPendingSlice` is true.\r\n     *\r\n     * The state will be {@link Stopwatch.State#STOPPED} after calling this method if\r\n     * the state is not currently {@link Stopwatch.State#IDLE}. otherwise, it will remain\r\n     * {@link Stopwatch.State#IDLE}.\r\n     *\r\n     * @param recordPendingSlice - If true, then also end/record the current pending slice.\r\n     *        This ensures that slice is ended exactly at the same time that the stopwatch\r\n     *        is stopped.\r\n     * @return the current {@link #getTime} result.\r\n     */\r\n    Stopwatch.prototype.stop = function (recordPendingSlice) {\r\n        if (recordPendingSlice === void 0) { recordPendingSlice = false; }\r\n        if (this.startSystemTime === undefined) {\r\n            return 0;\r\n        }\r\n        var systemTimeOfStopwatchTime = this.getSystemTimeOfCurrentStopwatchTime();\r\n        if (recordPendingSlice) {\r\n            this.recordPendingSlice(this.calculateStopwatchTime(systemTimeOfStopwatchTime));\r\n        }\r\n        this.stopSystemTime = systemTimeOfStopwatchTime;\r\n        return this.getTime();\r\n    };\r\n    /**\r\n     * Completely resets this stopwatch to its initial state.\r\n     * Clears out all recorded running duration, slices, etc.\r\n     * The state is guaranteed to be {@link Stopwatch.State#IDLE} after\r\n     * calling this method.\r\n     */\r\n    Stopwatch.prototype.reset = function () {\r\n        this.startSystemTime = this.pendingSliceStartStopwatchTime = this.stopSystemTime = undefined;\r\n        this.stopDuration = 0;\r\n        this.completedSlices = [];\r\n    };\r\n    /**\r\n     * Gets the system time equivalent of the current stopwatch time.\r\n     * If this stopwatch is currently stopped, then the system time at which it was\r\n     * stopped is returned.\r\n     * Otherwise, the current system time according to {@link Stopwatch#getSystemTime} is\r\n     * returned.\r\n     * @return the system time equivalent of the current stopwatch time.\r\n     */\r\n    Stopwatch.prototype.getSystemTimeOfCurrentStopwatchTime = function () {\r\n        return this.stopSystemTime === undefined\r\n            ? this.getSystemTime()\r\n            : this.stopSystemTime;\r\n    };\r\n    /**\r\n     * Calculates the current stopwatch time as of a specified system time.\r\n     * @param endSystemTime - The end system time for the calculation.\r\n     * @return the current stopwatch time as of the specified system time.\r\n     */\r\n    Stopwatch.prototype.calculateStopwatchTime = function (endSystemTime) {\r\n        if (this.startSystemTime === undefined) {\r\n            return 0;\r\n        }\r\n        if (endSystemTime === undefined) {\r\n            endSystemTime = this.getSystemTimeOfCurrentStopwatchTime();\r\n        }\r\n        return endSystemTime - this.startSystemTime - this.stopDuration;\r\n    };\r\n    /**\r\n     * Calculates the current pending slice as of a specified stopwatch time.\r\n     * @param endStopwatchTime - The end stopwatch time for the calculation.\r\n     * @return the current pending slice as of the specified stopwatch time.\r\n     */\r\n    Stopwatch.prototype.calculatePendingSlice = function (endStopwatchTime) {\r\n        if (this.pendingSliceStartStopwatchTime === undefined) {\r\n            return Object.freeze({\r\n                startTime: 0,\r\n                endTime: 0,\r\n                duration: 0\r\n            });\r\n        }\r\n        if (endStopwatchTime === undefined) {\r\n            endStopwatchTime = this.getTime();\r\n        }\r\n        return Object.freeze({\r\n            startTime: this.pendingSliceStartStopwatchTime,\r\n            endTime: endStopwatchTime,\r\n            duration: endStopwatchTime - this.pendingSliceStartStopwatchTime\r\n        });\r\n    };\r\n    /**\r\n     * Private implementation of ending/recording the currently pending slice.\r\n     * See {@link #slice} for more explanation.\r\n     * @param endStopwatchTime - The end stopwatch time of the slice.\r\n     * @return the recorded slice.\r\n     */\r\n    Stopwatch.prototype.recordPendingSlice = function (endStopwatchTime) {\r\n        if (this.pendingSliceStartStopwatchTime !== undefined) {\r\n            if (endStopwatchTime === undefined) {\r\n                endStopwatchTime = this.getTime();\r\n            }\r\n            var slice = this.calculatePendingSlice(endStopwatchTime);\r\n            // Start the next pending slice\r\n            this.pendingSliceStartStopwatchTime = slice.endTime;\r\n            // Record the slice\r\n            this.completedSlices.push(slice);\r\n            return slice;\r\n        }\r\n        else {\r\n            return this.calculatePendingSlice();\r\n        }\r\n    };\r\n    return Stopwatch;\r\n}());\r\nexport { Stopwatch };\r\n(function (Stopwatch) {\r\n    /**\r\n     * Possible states of a {@link Stopwatch}.\r\n     */\r\n    var State;\r\n    (function (State) {\r\n        /**\r\n         * The stopwatch has not yet been started, or has been reset.\r\n         */\r\n        State[\"IDLE\"] = \"IDLE\";\r\n        /**\r\n         * The stopwatch is currently running.\r\n         */\r\n        State[\"RUNNING\"] = \"RUNNING\";\r\n        /**\r\n         * The stopwatch was previously running, but has been stopped.\r\n         */\r\n        State[\"STOPPED\"] = \"STOPPED\";\r\n    })(State = Stopwatch.State || (Stopwatch.State = {}));\r\n    /**\r\n     * Sets the default implementation of \"getSystemTime\" to be used by all future\r\n     * instances of {@link Stopwatch}.\r\n     * @param systemTimeGetter - A default \"getSystemTime\" implementation for\r\n     *        all future instances of {@link Stopwatch}.\r\n     *        Defaults to {@link Date.now}.\r\n     */\r\n    function setDefaultSystemTimeGetter(systemTimeGetter) {\r\n        if (systemTimeGetter === void 0) { systemTimeGetter = Date.now; }\r\n        defaultSystemTimeGetter = systemTimeGetter;\r\n    }\r\n    Stopwatch.setDefaultSystemTimeGetter = setDefaultSystemTimeGetter;\r\n})(Stopwatch || (Stopwatch = {}));\r\n/**\r\n * The default \"getSystemTime\" implementation for all new instances of\r\n * {@link Stopwatch}.\r\n * Defaults to {@link Date.now}.\r\n * Updated via {@link Stopwatch.setDefaultSystemTimeGetter}.\r\n */\r\nvar defaultSystemTimeGetter = Date.now;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}